"""Distribution generators for discrete-event simulation.

This module provides distribution classes for generating random variates
in queueing simulations. All distributions support reproducible random
number generation through seeding.
"""

from abc import ABC, abstractmethod
import logging

import numpy as np
from scipy.stats import truncnorm

from src.simulations.core.enums import DistributionType
from src.simulations.core.schemas import DistributionParams


logger = logging.getLogger(__name__)


class Distribution(ABC):
    """Abstract base class for probability distributions.

    All distribution implementations must inherit from this class and
    implement the generate() method.

    Attributes:
        rng: NumPy random number generator for reproducible results.
        _generation_count: Counter for number of variates generated.
    """

    def __init__(self, rng: np.random.Generator | None = None) -> None:
        """Initialize the distribution.

        Args:
            rng: NumPy random generator. If None, creates a new generator.
        """
        self.rng = rng if rng is not None else np.random.default_rng()
        self._generation_count = 0

    @abstractmethod
    def generate(self) -> float:
        """Generate a single random variate.

        Returns:
            A random value from this distribution.

        Raises:
            NotImplementedError: If subclass doesn't implement this method.
        """
        raise NotImplementedError("Subclasses must implement generate()")

    @abstractmethod
    def get_mean(self) -> float:
        """Calculate theoretical mean of the distribution.

        Returns:
            The expected value (mean) of the distribution.
        """
        raise NotImplementedError("Subclasses must implement get_mean()")

    @abstractmethod
    def get_params(self) -> dict:
        """Get distribution parameters.

        Returns:
            Dictionary containing the distribution parameters.
        """
        raise NotImplementedError("Subclasses must implement get_params()")

    def generate_batch(self, size: int) -> np.ndarray:
        """Generate multiple random variates.

        Args:
            size: Number of variates to generate.

        Returns:
            NumPy array of random variates.

        Raises:
            ValueError: If size is not positive.
        """
        if size <= 0:
            raise ValueError(f"Size must be positive, got {size}")

        return np.array([self.generate() for _ in range(size)])

    @property
    def generation_count(self) -> int:
        """Get the number of variates generated.

        Returns:
            Total number of random variates generated by this instance.
        """
        return self._generation_count

    def reset_count(self) -> None:
        """Reset the generation counter to zero."""
        self._generation_count = 0

    @abstractmethod
    def __repr__(self) -> str:
        """String representation of the distribution."""
        raise NotImplementedError("Subclasses must implement __repr__()")


class ExponentialDistribution(Distribution):
    """Exponential distribution for inter-arrival or service times.

    The exponential distribution is commonly used for modeling:
    - Inter-arrival times in Poisson processes
    - Service times in queuing systems
    - Lifetimes of components

    Attributes:
        rate: Rate parameter (λ > 0). Higher rate means shorter times.
        scale: Scale parameter (1/λ), the mean of the distribution.

    Examples:
        >>> exp_dist = ExponentialDistribution(rate=2.0)
        >>> sample = exp_dist.generate()
        >>> mean = exp_dist.get_mean()  # Returns 0.5
    """

    def __init__(
        self, rate: float, rng: np.random.Generator | None = None
    ) -> None:
        """Initialize exponential distribution.

        Args:
            rate: Rate parameter (λ > 0).
            rng: NumPy random generator. If None, creates a new generator.

        Raises:
            ValueError: If rate is not positive.
        """
        if rate <= 0:
            raise ValueError(f"Rate must be positive, got {rate}")

        super().__init__(rng)
        self.rate = rate
        self.scale = 1.0 / rate

    def generate(self) -> float:
        """Generate exponentially distributed random variate.

        Returns:
            Random value from Exp(λ).
        """
        self._generation_count += 1
        return self.rng.exponential(self.scale)

    def get_mean(self) -> float:
        """Calculate theoretical mean.

        Returns:
            Mean = 1/λ.
        """
        return self.scale

    def get_params(self) -> dict:
        """Get distribution parameters.

        Returns:
            Dictionary with 'rate' and 'scale' keys.
        """
        return {"rate": self.rate, "scale": self.scale}

    def __repr__(self) -> str:
        """String representation.

        Returns:
            String like "Exponential(λ=2.0, mean=0.5)".
        """
        return f"Exponential(λ={self.rate}, mean={self.scale})"


class UniformDistribution(Distribution):
    """Uniform distribution over interval [a, b].

    The uniform distribution assigns equal probability to all values
    in the interval [a, b].

    Attributes:
        a: Lower bound of the interval.
        b: Upper bound of the interval.

    Examples:
        >>> uniform_dist = UniformDistribution(a=1.0, b=5.0)
        >>> sample = uniform_dist.generate()  # Returns value in [1, 5]
    """

    def __init__(
        self, a: float, b: float, rng: np.random.Generator | None = None
    ) -> None:
        """Initialize uniform distribution.

        Args:
            a: Lower bound.
            b: Upper bound.
            rng: NumPy random generator. If None, creates a new generator.

        Raises:
            ValueError: If a >= b.
        """
        if a >= b:
            raise ValueError(
                f"Lower bound must be less than upper bound, got a={a}, b={b}"
            )

        super().__init__(rng)
        self.a = a
        self.b = b

    def generate(self) -> float:
        """Generate uniformly distributed random variate.

        Returns:
            Random value from U[a, b].
        """
        self._generation_count += 1
        return self.rng.uniform(self.a, self.b)

    def get_mean(self) -> float:
        """Calculate theoretical mean.

        Returns:
            Mean = (a + b) / 2.
        """
        return (self.a + self.b) / 2.0

    def get_params(self) -> dict:
        """Get distribution parameters.

        Returns:
            Dictionary with 'a' and 'b' keys.
        """
        return {"a": self.a, "b": self.b}

    def __repr__(self) -> str:
        """String representation.

        Returns:
            String like "Uniform[1.0, 5.0]".
        """
        return f"Uniform[{self.a}, {self.b}]"


class GammaDistribution(Distribution):
    """Gamma distribution for modeling service times.

    The gamma distribution is a two-parameter family of continuous
    probability distributions. It's useful for modeling waiting times
    and service times.

    Attributes:
        k: Shape parameter (k > 0).
        theta: Scale parameter (θ > 0).

    Examples:
        >>> gamma_dist = GammaDistribution(k=2.0, theta=1.5)
        >>> sample = gamma_dist.generate()
    """

    def __init__(
        self, k: float, theta: float, rng: np.random.Generator | None = None
    ) -> None:
        """Initialize gamma distribution.

        Args:
            k: Shape parameter (k > 0).
            theta: Scale parameter (θ > 0).
            rng: NumPy random generator. If None, creates a new generator.

        Raises:
            ValueError: If k or theta is not positive.
        """
        if k <= 0:
            raise ValueError(f"Shape parameter k must be positive, got {k}")
        if theta <= 0:
            raise ValueError(
                f"Scale parameter theta must be positive, got {theta}"
            )

        super().__init__(rng)
        self.k = k
        self.theta = theta

    def generate(self) -> float:
        """Generate gamma distributed random variate.

        Returns:
            Random value from Gamma(k, θ).
        """
        self._generation_count += 1
        return self.rng.gamma(self.k, self.theta)

    def get_mean(self) -> float:
        """Calculate theoretical mean.

        Returns:
            Mean = k * θ.
        """
        return self.k * self.theta

    def get_params(self) -> dict:
        """Get distribution parameters.

        Returns:
            Dictionary with 'k' and 'theta' keys.
        """
        return {"k": self.k, "theta": self.theta}

    def __repr__(self) -> str:
        """String representation.

        Returns:
            String like "Gamma(k=2.0, θ=1.5)".
        """
        return f"Gamma(k={self.k}, θ={self.theta})"


class WeibullDistribution(Distribution):
    """Weibull distribution for failure times and service times.

    The Weibull distribution is widely used in reliability engineering
    and failure analysis. It can model increasing, decreasing, or
    constant failure rates.

    Attributes:
        k: Shape parameter (k > 0).
        lambda_param: Scale parameter (λ > 0).

    Examples:
        >>> weibull_dist = WeibullDistribution(k=1.5, lambda_param=2.0)
        >>> sample = weibull_dist.generate()
    """

    def __init__(
        self,
        k: float,
        lambda_param: float,
        rng: np.random.Generator | None = None,
    ) -> None:
        """Initialize Weibull distribution.

        Args:
            k: Shape parameter (k > 0).
            lambda_param: Scale parameter (λ > 0).
            rng: NumPy random generator. If None, creates a new generator.

        Raises:
            ValueError: If k or lambda_param is not positive.
        """
        if k <= 0:
            raise ValueError(f"Shape parameter k must be positive, got {k}")
        if lambda_param <= 0:
            raise ValueError(
                f"Scale parameter lambda must be positive, got {lambda_param}"
            )

        super().__init__(rng)
        self.k = k
        self.lambda_param = lambda_param

    def generate(self) -> float:
        """Generate Weibull distributed random variate.

        Returns:
            Random value from Weibull(k, λ).
        """
        self._generation_count += 1
        return self.lambda_param * self.rng.weibull(self.k)

    def get_mean(self) -> float:
        """Calculate theoretical mean.

        Uses the gamma function: E[X] = λ * Γ(1 + 1/k)

        Returns:
            Mean = λ * Γ(1 + 1/k).
        """
        from math import gamma

        return self.lambda_param * gamma(1.0 + 1.0 / self.k)

    def get_params(self) -> dict:
        """Get distribution parameters.

        Returns:
            Dictionary with 'k' and 'lambda_param' keys.
        """
        return {"k": self.k, "lambda_param": self.lambda_param}

    def __repr__(self) -> str:
        """String representation.

        Returns:
            String like "Weibull(k=1.5, λ=2.0)".
        """
        return f"Weibull(k={self.k}, λ={self.lambda_param})"


class TruncatedNormalDistribution(Distribution):
    """Truncated normal distribution with bounds [a, b].

    The truncated normal distribution is a normal distribution bounded
    to a specific interval. Useful when values must be positive or
    within a certain range.

    Attributes:
        mu: Mean of the underlying normal distribution.
        sigma: Standard deviation of the underlying normal (σ > 0).
        a: Lower truncation bound.
        b: Upper truncation bound.

    Examples:
        >>> tn_dist = TruncatedNormalDistribution(mu=5.0, sigma=2.0, a=0.0, b=10.0)
        >>> sample = tn_dist.generate()  # Returns value in [0, 10]
    """

    def __init__(
        self,
        mu: float,
        sigma: float,
        a: float,
        b: float,
        rng: np.random.Generator | None = None,
    ) -> None:
        """Initialize truncated normal distribution.

        Args:
            mu: Mean of underlying normal.
            sigma: Standard deviation of underlying normal (σ > 0).
            a: Lower truncation bound.
            b: Upper truncation bound.
            rng: NumPy random generator. If None, creates a new generator.

        Raises:
            ValueError: If sigma is not positive or a >= b.
        """
        if sigma <= 0:
            raise ValueError(
                f"Standard deviation must be positive, got {sigma}"
            )
        if a >= b:
            raise ValueError(
                f"Lower bound must be less than upper bound, got a={a}, b={b}"
            )

        super().__init__(rng)
        self.mu = mu
        self.sigma = sigma
        self.a = a
        self.b = b

        # Standardized bounds for scipy
        self.a_std = (a - mu) / sigma
        self.b_std = (b - mu) / sigma

    def generate(self) -> float:
        """Generate truncated normal random variate.

        Returns:
            Random value from TN(μ, σ, a, b).
        """
        self._generation_count += 1
        return truncnorm.rvs(
            self.a_std,
            self.b_std,
            loc=self.mu,
            scale=self.sigma,
            random_state=self.rng,
        )

    def get_mean(self) -> float:
        """Calculate theoretical mean of truncated normal.

        Returns:
            Approximate mean (exact calculation is complex).
        """
        return truncnorm.mean(
            self.a_std, self.b_std, loc=self.mu, scale=self.sigma
        )

    def get_params(self) -> dict:
        """Get distribution parameters.

        Returns:
            Dictionary with 'mu', 'sigma', 'a', and 'b' keys.
        """
        return {"mu": self.mu, "sigma": self.sigma, "a": self.a, "b": self.b}

    def __repr__(self) -> str:
        """String representation.

        Returns:
            String like "TruncatedNormal(μ=5.0, σ=2.0, [0.0, 10.0])".
        """
        return f"TruncatedNormal(μ={self.mu}, σ={self.sigma}, [{self.a}, {self.b}])"


class EmpiricalDistribution(Distribution):
    """Empirical distribution based on observed data.

    This distribution allows to use real-world observed data
    to generate random variates. Two methods are supported:

    1. **Inverse Transform (ECDF)**: Uses the empirical cumulative
       distribution function. Fast and preserves exact data range.

    2. **Kernel Density Estimation (KDE)**: Fits a smooth continuous
       distribution to the data. Can generate values outside the
       observed range.

    Attributes:
        data: Sorted array of observed values.
        method: Sampling method ('kde' or 'inverse_transform').
        kde: Scipy KDE object (if method='kde').
        ecdf: Empirical CDF values (if method='inverse_transform').

    Examples:
        >>> # From observed service times
        >>> data = [1.2, 1.5, 2.1, 1.8, 2.3, 1.9, 2.0]
        >>> dist = EmpiricalDistribution(data, method='inverse_transform')
        >>> sample = dist.generate()  # Returns value in [1.2, 2.3]

        >>> # With KDE for smooth interpolation
        >>> dist_kde = EmpiricalDistribution(data, method='kde')
        >>> sample_kde = dist_kde.generate()  # May be outside [1.2, 2.3]
    """

    def __init__(
        self,
        data: list[float],
        method: str = "inverse_transform",
        bandwidth: float | None = None,
        rng: np.random.Generator | None = None,
    ) -> None:
        """Initialize empirical distribution.

        Args:
            data: List of observed values (minimum 2 points).
            method: 'inverse_transform' (ECDF) or 'kde'.
            bandwidth: KDE bandwidth (optional, auto-detected if None).
            rng: NumPy random generator. If None, creates a new generator.

        Raises:
            ValueError: If data has less than 2 points or method is invalid.
        """
        if len(data) < 2:
            raise ValueError(
                f"Empirical distribution requires at least 2 data points, got {len(data)}"
            )

        if method not in ("inverse_transform", "kde"):
            raise ValueError(
                f"Method must be 'inverse_transform' or 'kde', got {method}"
            )

        super().__init__(rng)
        self.data = np.sort(data)  # Sort for ECDF
        self.method = method
        self.bandwidth = bandwidth

        if method == "kde":
            self._initialize_kde()
        else:
            self._initialize_ecdf()

    def _initialize_kde(self) -> None:
        """Initialize Kernel Density Estimation."""
        from scipy.stats import gaussian_kde

        if self.bandwidth is not None:
            self.kde = gaussian_kde(self.data, bw_method=self.bandwidth)
        else:
            # Use Scott's rule (default)
            self.kde = gaussian_kde(self.data)

        logger.debug(
            "Initialized KDE with %d data points, bandwidth=%.4f",
            len(self.data),
            self.kde.factor,
        )

    def _initialize_ecdf(self) -> None:
        """Initialize Empirical CDF for inverse transform sampling."""
        n = len(self.data)
        # ECDF: F(x) = (number of observations ≤ x) / n
        self.ecdf = np.arange(1, n + 1) / n

        logger.debug(
            "Initialized ECDF with %d data points, range=[%.4f, %.4f]",
            n,
            self.data[0],
            self.data[-1],
        )

    def generate(self) -> float:
        """Generate a random variate from the empirical distribution.

        Returns:
            Random value sampled from the empirical distribution.
        """
        self._generation_count += 1

        if self.method == "kde":
            # Sample from KDE
            return float(self.kde.resample(1, seed=self.rng)[0, 0])
        else:
            # Inverse transform sampling
            u = self.rng.uniform(0, 1)
            # Find the value corresponding to CDF = u
            idx = np.searchsorted(self.ecdf, u, side="right")
            # Handle edge cases
            if idx >= len(self.data):
                return self.data[-1]
            elif idx == 0:
                return self.data[0]
            else:
                # Linear interpolation between data points
                x0, x1 = self.data[idx - 1], self.data[idx]
                f0, f1 = self.ecdf[idx - 1], self.ecdf[idx]
                # Interpolate
                if f1 - f0 > 0:
                    alpha = (u - f0) / (f1 - f0)
                    return float(x0 + alpha * (x1 - x0))
                else:
                    return float(x0)

    def get_mean(self) -> float:
        """Calculate empirical mean.

        Returns:
            Sample mean of the observed data.
        """
        return float(np.mean(self.data))

    def get_variance(self) -> float:
        """Calculate empirical variance.

        Returns:
            Sample variance of the observed data.
        """
        return float(np.var(self.data, ddof=1))

    def get_std(self) -> float:
        """Calculate empirical standard deviation.

        Returns:
            Sample standard deviation of the observed data.
        """
        return float(np.std(self.data, ddof=1))

    def get_params(self) -> dict:
        """Get distribution parameters.

        Returns:
            Dictionary with data statistics and method.
        """
        return {
            "method": self.method,
            "data_size": len(self.data),
            "data_min": float(self.data[0]),
            "data_max": float(self.data[-1]),
            "data_mean": self.get_mean(),
            "data_std": self.get_std(),
            "bandwidth": self.bandwidth if self.method == "kde" else None,
        }

    def __repr__(self) -> str:
        """String representation.

        Returns:
            String like "Empirical(n=100, method=kde, range=[1.2, 5.4])".
        """
        return (
            f"Empirical(n={len(self.data)}, method={self.method}, "
            f"range=[{self.data[0]:.2f}, {self.data[-1]:.2f}])"
        )


def get_distribution(
    params: DistributionParams, rng: np.random.Generator | None = None
) -> Distribution:
    """Factory function to create distribution objects.

    Args:
        params: Distribution parameters from Pydantic schema.
        rng: Optional random number generator for reproducibility.

    Returns:
        Distribution object corresponding to the parameters.

    Raises:
        NotImplementedError: If distribution type is not supported.

    Examples:
        >>> from src.simulations.core.schemas import ExponentialParams
        >>> params = ExponentialParams(rate=2.0)
        >>> dist = get_distribution(params)
        >>> sample = dist.generate()
    """
    if params.distribution == DistributionType.EXPONENTIAL:
        return ExponentialDistribution(rate=params.rate, rng=rng)

    if params.distribution == DistributionType.UNIFORM:
        return UniformDistribution(a=params.a, b=params.b, rng=rng)

    if params.distribution == DistributionType.GAMMA:
        return GammaDistribution(k=params.k, theta=params.theta, rng=rng)

    if params.distribution == DistributionType.WEIBULL:
        return WeibullDistribution(
            k=params.k, lambda_param=params.lambda_param, rng=rng
        )

    if params.distribution == DistributionType.TRUNCATED_NORMAL:
        return TruncatedNormalDistribution(
            mu=params.mu, sigma=params.sigma, a=params.a, b=params.b, rng=rng
        )

    if params.distribution == DistributionType.EMPIRICAL:
        return EmpiricalDistribution(
            data=params.data,
            method=params.method,
            bandwidth=params.bandwidth,
            rng=rng,
        )

    raise NotImplementedError(
        f"Distribution '{params.distribution}' is not supported."
    )
